[{"title":"TypeError The header content contains invalid characters","date":"2017-11-04T07:56:42.000Z","path":"2017/11/04/T7ildrYrjZMrsfzN/","text":"nodejs运行过程中出现此错误 1TypeError: The header content contains invalid characters 出现此原因发现是在执行ctx.redirect 的时候出现的，经检查发现为redirect的url中包含了中文，修改为redirect(encodeURI(url))即可。 —-publish by CEditor","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":" http","slug":"http","permalink":"http://blog.cuiyy.top/tags/http/"}]},{"title":"Pow 快速创建静态网页服务器","date":"2017-10-20T07:36:23.000Z","path":"2017/10/20/IhU1Rkv60ls2ja09/","text":"Pow是Mac OS X的零配置机架式服务器。 安装Pow需要Mac OS X 10.9或更高版本。要安装或升级Pow，只需打开终端并运行以下命令 1curl get.pow.cx | sh 使用只需将静态文件目录链接到您的~/.pow 目录中即可。假设你有个应用程序放在 ~/Projects/myapp中，并且包含了public目录，你想要这样访问它 http://myapp.dev/；可以这样设置： 12cd ~/.powln -s ~/Projects/myapp 如果您有一个静态站点，并希望将文件保留在项目的根目录中（即不在 public目录中），则可以执行以下操作： 1234cd ~/.powmkdir your-app-domaincd !$ln -s ~/Projects/your-app public —-publish by CEditor","tags":[{"name":" 工具","slug":"工具","permalink":"http://blog.cuiyy.top/tags/工具/"}]},{"title":"前端mac系统重装之后","date":"2017-10-17T10:20:50.000Z","path":"2017/10/17/etb9IVimFgncBxLQ/","text":"最近刚更新了 macOS High Sierra，更新过程非常坎坷，最后终于安装成功了，但是曾经装的软件什么的都没有了，需要重新安装，这里列出我所安装的软件列表： 系统常用 chrome浏览器 百度输入法 Magnet 分屏软件 iPic 图片上传神器 全能解压 Alfred Sip 拾色工具 1Password 社交 微信 qq 钉钉 写作笔记 有道云笔记 印象笔记 编辑器 Sublime Text 3 (package control) VScode Shell增强 oh my zsh Homebrew wget (brew install wget) autojump (brew install autojump)如果link失败可执行 1sudo chown -R $(whoami) /usr/local/share/ 代码管理 Git生成KEY：123git config --global user.name “xx”git config --global user.email “x@gmail.com\"ssh-keygen -t rsa -C “xx@gmail.com” 开发相关 Nodejs nodemon (npm install -g nodemon) node更改自动重启 yarn （node包管理） cnpm 淘宝 NPM 镜像 1npm install -g cnpm --registry=https://registry.npm.taobao.org Mongodb MySQL Robo 3T mongo客户端 Navicat for mysql MySQL客户端 Redis RedisDesktopManager Redis客户端 Memcached 缓存管理 其他 Scss 前端CSS扩展语言 vim 设置123vim ~/.zshrcsyntax onset nu # 显示行号 —-publish by CEditor","tags":[{"name":" 工具","slug":"工具","permalink":"http://blog.cuiyy.top/tags/工具/"}]},{"title":"Weex 项目 Android部署","date":"2017-10-16T09:52:41.000Z","path":"2017/10/16/0ySGeMATlDSbikLM/","text":"环境要求1、安装 Android Studio或者 Android SDK 2、 安装 Android SDK Build-Tools 23.0.2版本 打开Android Studio&gt;Tools&gt;Android&gt;SDK Manager，选择SDK Tools选项， 选择Show Package Details; 找到 23.0.2勾选并安装。 3、配置环境变量,执行vim ~/.bash_profile 增加如下代码：123export ANDROID_HOME=/Users/you/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools 保存后执行resource ~/.bash_profile,使修改生效；如果你用了其他终端，如『zsh』，可将 . ~/.bash_profile命令添加到~/.zshrc中； jdk 安装下载安装jdk 8，如果安装了9版本会在运行时，出现编译失败问题，如下图： 如果需要多个jdk版本可添加别名，实现快速切换使用；可在.bash_profile中增加如下代码1234export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`export JAVA_9_HOME=`/usr/libexec/java_home -v 9`alias jdk8=\"export JAVA_HOME=$JAVA_8_HOME\"alias jdk9=\"export JAVA_HOME=$JAVA_9_HOME\" 此时可通过jdk8、jdk9随意切换版本。 运行一切准备就绪后在终端运行以下命令，增加安卓端支持：12weex platform add androidweex run android 运行过程中会下载一堆的jar包；并会出现以下错误： 提示缺少安卓设备，我们可以在Android Studio中设置虚拟机，也可以用USB连接安卓手机，并打开调试模式，然后重新执行weex run android; 如果运行成功，可在手机上看到生成的程序，并自动打开。 注：有些手机可能会有一些权限问题导致不能自动安装成功，需要响应的设置才行。 —-publish by CEditor","tags":[{"name":"weex","slug":"weex","permalink":"http://blog.cuiyy.top/tags/weex/"}]},{"title":"MongoDB开启权限验证的方法","date":"2017-10-13T03:40:10.000Z","path":"2017/10/13/O74WjrqshGRNERf1/","text":"基本角色 root 这是超级管理员 userAdminAnyDatabase 这个角色拥有分配角色和用户的权限，但没有查写的权限 readWrite 有读写权限 read 有读权限 创建一个超级用户123456789use admindb.createUser(&#123; user: \"root\", pwd: \"cyy_mongo\", roles: [&#123; \"role\" : \"root\", \"db\" : \"admin\" &#125;]&#125;) db是指定数据库的名字，admin是管理数据库。 开启认证进入mongod.conf配置文件，将auth 改为true；重启mongo服务； 权限登录1mongo --host xxx -u adminUserName -p userPassword --authenticationDatabase admin 其他查看当前用户的权限1234db.runCommand(&#123; usersInfo:\"userName\", showPrivileges:true&#125;) 创建一般用户，也是用createUser123456789db.createUser(&#123; user:\"user1\", pwd:\"12345\", roles:[ &#123;role:\"read\",db:\"db1\"&#125;, &#123;role:\"read\",db:\"db2\"&#125;, &#123;role:\"read\",db:\"db3\"&#125; ]&#125;) 修改密码12use admindb.changeUserPassword(\"username\", \"xxx\") 查看用户信息1db.runCommand(&#123;usersInfo:\"userName\"&#125;) 修改密码和用户信息12345db.runCommand(&#123; updateUser:\"username\", pwd:\"xxx\", customData:&#123;title:\"xxx\"&#125;&#125;) —-publish by CEditor","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.cuiyy.top/tags/mongodb/"}]},{"title":"为了遇见你","date":"2017-10-12T07:17:52.000Z","path":"2017/10/12/dVIMLDDUxriU57uW/","text":"—-publish by CEditor","tags":[{"name":"其他","slug":"其他","permalink":"http://blog.cuiyy.top/tags/其他/"}]},{"title":"ssh 免密码登录","date":"2017-10-10T05:00:31.000Z","path":"2017/10/10/Ja5aO9RFlMdvjYBE/","text":"开发过程中，经常需要使用ssh登录远程主机，每次都要输入密码，影响效率，这里讲解一下，怎么使用ssh无密码登录。 本机生成ssh keyssh 无密码登录要使用公钥与私钥。linux下可以用用ssh-keygen生成公钥/私钥对。 1ssh-keygen -t rsa -C \"xxx@email.com\" 然后一路回车即可。 然后可以通过以下命令查看到生成的公钥： 1cat ~/.ssh/id_rsa.pub 远程主机生成ssh key先通过ssh登录到远程主机， 并以同样的方式生成ssh key 复制本机公钥到远程文件把本地的id_rsa.pub文件中的内容复制到远程主机的.ssh/authorized_keys文件里. authorized_keys文件如果没有，可以自己手动创建。 添加完成后，退出重新使用ssh 登录时，就不需要输入密码了。","tags":[{"name":"ssh","slug":"ssh","permalink":"http://blog.cuiyy.top/tags/ssh/"}]},{"title":"nodejs使用socket.io实现分布式一对一发送消息","date":"2017-09-27T09:13:53.000Z","path":"2017/09/27/QkkxF6N8eMj7mVKX/","text":"最近在用nodejs实现一个消息通知的功能，其中用到了socket.io；由于初次使用socket.io，在网上查找资料大都是聊天室广播的教程，没有找到一对一发送消息的具体实现方法，这里分享一下自己学习使用过程中踩到某些坑和最终实现方法。 要实现的功能:server端数据更新后，发送通知到对应客户端的用户；server是用nodejs写的，并使用了分布式，同时开启了多个实例。 一、安装依赖包 1npm install socket.io 二、socket.io的使用1、index.js 文件内容 12345678//index.jsvar express = require('express');var app = express();var server = require('http').Server(app);var io = require('socket.io')(server,&#123; \"path\":\"/notice\" //修改客户端请求的路径，默认为/socket.io&#125;);new (require(\"./notice\").init)(io); //传入io 2、notice.js文件内容 1234567891011121314151617181920212223242526272829303132333435var Notice = null; var socketMap = &#123;&#125;; //用户对应socket.id//初始化socket连接exports.init = function (io)&#123; //连接验证 io.use(function(socket, next)&#123; //console.log(socket.request.headers.cookie); var token = socket.request._query.token || \"\"; if(validate(token))&#123; socket.request.headers.user = &#123;userId:userId&#125;; return next(); &#125;else&#123; return next(new Error('Authentication error')); &#125; &#125;); Notice = io.of(\"/notice\").on('connection', function(socket) &#123; var user = socket.handshake.headers.user; var user_id = user &amp;&amp; user.userId; if(user_id)&#123; socketMap[user_id] = socket.id; &#125; socket.on('disconnect', function() &#123; delete socketMap[user_id]; &#125;); &#125;);&#125;//其他模块调用，发送消息exports.send = function(data)&#123; var user_id = data.accountID; var socket_id = socketMap[user_id]; Notice.to(socket_id).emit('notice', data);&#125; 3、客户端文件 1234567&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://localhost?token=token'); socket.on('notice', function (data) &#123; console.log(data); &#125;);&lt;/script&gt; 在跨域请求的情况下socket.request.headers.cookie是无法获取到有效的cookie的，所以这里直接从客户端传token过来进行验证。验证通过后，将用户信息存到headers中，客户端连接成功后，取出用户信息，并将用户id与此socket连接对应id存储到全局socketMap变量中，然后外部模块通过调用send方法来发送消息。 这种情况在单实例情况下是没有问题的，但是如果server开启了多个实例就出问题了。 三、使用nginx实现分布式部署首先需要安装nginx；安装完成后编写配置文件； 123456789101112131415161718upstream socket_test &#123; ip_hash; server 127.0.0.1:8013; server 127.0.0.1:8014;&#125;server &#123; listen 80; server_name socket.test.com; location / &#123; proxy_pass http://socket_test/; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 启动两个项目实例，分别监听8013和8014端口；然后启动nginx 1sudo nginx 通过测试会发现，消息有时候能收到，有时候收不到。原因是因为客户端请求的时候，会不定的请求服务端两个实例中的一个，如果连接的时候是请求的8013端口的实例，二发送消息是8014端口的实例 ，就会在8014的实例中找不到建立连接的socket。 四、分布式解决方法socket.io官网中提供了使用socket.io-redis来解决此方法；socket.io-redis中使用了redis的消息订阅与发布的功能，当有通知发送的时候，会触发onmessage事件，然后会调用broadcast广播。 接下来将socket.io-redis添加到index.js文件中 12345678910 //index.jsvar express = require('express');var app = express();var server = require('http').Server(app);var io = require('socket.io')(server,&#123; \"path\":\"/notice\" //修改客户端请求的路径，默认为/socket.io&#125;);new (require(\"./notice\").init)(io); //传入iovar redis = require('socket.io-redis');io.adapter(redis(&#123; host: settings.REDIS_HOST, port: settings.REDIS_PORT &#125;)); 然后重启后会发现还是不行，原因是因为在socketMap变量中有时候就找不到对应的user_id;因为是分布式的，所有socketMap变量在两台实例中并不是共享的，所以这里使用redis，在socket建立的时候将user_id对应的socket_id存储到redis中，发送消息的时候从redis中读取socket_id这样就可以了。 有时候一个用户可能会同时有多个socket连接，所以user_id对应的socket_id就可以是一个数组，发送消息的时候要循环发送，连接断开的时候要只删除对应的socket_id,保留其他建立的连接。 另外服务器重启时socket会重新建立连接，所以在初始化的的时候要清空redis中所有存储的数据。 —-publish by CEditor","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"socket.io","slug":"socket-io","permalink":"http://blog.cuiyy.top/tags/socket-io/"}]},{"title":"GitHub webhooks实现自动部署","date":"2017-09-27T03:33:39.000Z","path":"2017/09/27/pM6JLsCa29henIyW/","text":"使用第三方Git仓库，实现代码的自动部署GitHub 提供了Webhooks的功能，我们通过相应的配置就可以实现在代码提交到GitHub后自动部署我们的项目 在GitHub添加部署服务器的ssh key1、首先在服务器生成ssh key2、添加ssh key到GitHub账户中 选择setting -&gt; SSH and GPG keys -&gt; New SSH Key 添加 配置Webhooks打开需要配置Webhooks的项目，点击Settings，选择Webhooks Webhooks 设置 设置触发事件后请求的地址及方法，并选择触发事件的类型，此处选择为push,当我们提交代码的时候触发；设置完成后，点击添加即可。 服务器编辑接受处理代码以nodejs 的 express为例： 1234567891011121314151617181920var shell = require('shelljs'); // shell npm 包工具var setting = require('../setting');var blogPath = setting.blog.path;module.exports = function (req, res) &#123; var body = req.body; console.log(body) // git 推送的数据 if (!shell.which('git')) &#123; // 判断是否存在git命令 shell.echo('Sorry, this script requires git'); shell.exit(1); &#125; var cd = shell.cd(blogPath); if (!cd.code)&#123; // 执行git代码拉取操作 if (shell.exec('git pull origin master').code !== 0) &#123; shell.echo('Error: Git pull error!'); shell.exit(1); &#125; &#125; res.end();&#125; —-publish by CEditor","tags":[{"name":"Git","slug":"Git","permalink":"http://blog.cuiyy.top/tags/Git/"},{"name":"webhooks","slug":"webhooks","permalink":"http://blog.cuiyy.top/tags/webhooks/"}]},{"title":"让你备受刮目相看的8个npm技巧","date":"2017-09-27T02:26:54.000Z","path":"2017/09/27/dp034EZKdW2mePbk/","text":"本文转载自：众成翻译译者：liuhui_is_me链接：http://www.zcfy.cc/article/3362原文：https://medium.freecodecamp.com/8-npm-tricks-you-can-use-to-impress-your-colleagues-dbdae1ef5f9e 你观看一个同事编码时候，你会看到一些速记和技巧被应用，有些方式你并不熟悉，那你就被鄙视了，这种事情在我们每一个一生都会发生的。 在这篇文章中，我将介绍一些很有用的npm技巧，还有很多这里并不能全收录，我们只关注那些相关的并且有益于我们每天的工作和开发的技巧。 基本的速记为了让大家的对npm有一个一致的理解，尤其是我们的新人，让我们快速了解基本的速记和确保没有错过任何细节。 安装安装包常规: npm install pkg, 速记: npm i pkg. 全局安装包:常规: npm i --global pkg, 速记: npm i -g pkg. 安装包并包含在依赖中:常规: npm i --save pkg, 速记: npm i -S pkg. 安装包并包含在开发依赖中:常规: npm i --save-dev pkg, 速记: npm i -D pkg. 其他的npm速记阅读npm博客 速记表. 下面开始有趣的内容。 1. 初始化一个新包我们都知道npm init，用来创建一个新的包。 但是，所有的问题都是匿名的，我们无论如何都会修改它的，那么怎么避免发生呢？ 使用npm init -y 和 npm init -f回到初始化！ 2. 运行测试命令另一个命令就是npm test,我们可能每天使用依次或者一天使用好几次。 如果我告诉你可以使用少于40%的字符去完成这个功能？我们经常使用，应该这样。 幸运的是，我们可以使用npm t，它就可以胜任 3. 枚举可用的脚本我们开始一个新项目，我们想知道如何开始。我们通常会问自己这样的问题：我们如何运行它？哪些脚本可用？ 一个方法是打开package.json文件并检查scripts部分。 我们可以做的更好，当然，我们只是运行npm run得到一个的所有可用的脚本的列表。 另外的可以选择是安装ntl (npm i -g ntl)，然后运行ntl在项目文件夹中。它也可以运行脚本，也很方面。 4. 枚举已经安装的包类似于可用的脚本，有时我们会问自己我们的项目中有哪些依赖项。 我们可以再次打开package.json文件和检查，但是我们已经做的更好了。 使用 npm ls --depth 0. 枚举全局安装包，使用npm ls -g --depth 0 5. 运行本地安装的可执行文件我们安装了一个包在我们的项目中，它是一个可执行的，但我们只能运行它通过一个新的脚本。你想知道为什么，或者如何克服它？ 首先，让我们了解为什么——当我们在终端中执行命令时，实际发生的是它在PATH环境变量中列出的所有路径中查找一个具有相同名称的可执行文件。这就是他们如何神奇地从任何地方都可以执行。本地安装的软件包登记他们的可执行文件在本地，所以他们不在我们的PATH路径中将不会被发现。 当我们运行这些可执行文件通过一个新脚本，它是如何工作的呢？你可能会问？很好的问题！这是因为这种方式运行时，NPM做了一点技巧和增加了一个额外的文件夹到PATH，/node_modules/.bin中。你可以看到它的运行npm run env | grep &quot;$PATH&quot;。你也可以运行只是npm run env 查看所有可用的环境变量，npm增加了一些更有趣的东西。/node_modules/.bin，如果你不知道，正是在本地安装的软件包放置可执行文件的地方。 我们可以运行 ./node_modules/.bin/mocha 在我们的项目中，看看将会发生什么. 很简单, 对吧? 仅仅运行 ./node_modules/.bin/ ，无论什么时候你想要运行本地已安装的可执行文件。 6. 在网上查找你想要的包你可能看到了repository这个入口在package.json文件中，疑问“这有什么好处？” 为了问答这个问题，仅仅运行npm repo然后在你的浏览器中查看。 与之类似,npm home命令进入主页。 如果你想打开你的包的主页npmjs.com，那是一个不错的速记，npm docs。 7. 在其他脚本前后运行脚本您可能熟悉诸如pretest之类的脚本，它允许您定义在test脚本之前运行的代码。 您可能会惊讶地发现，您可以为每个脚本配置或有或后的脚本，包括您自己的自定义脚本！ 对于项目中，你使用NPM作为您的构建工具，有很多脚本，你需要自己总结使用。 8. 修改包的版本你开发一个安装包，你使用semver作为版本管理工具，修改一个新版本。 通过这种方式，你需要手动的修改package.json文件，我们不推荐这样做。 更容易的方式是运行npm version 通过 major, minor 或者 patch","tags":[{"name":"npm","slug":"npm","permalink":"http://blog.cuiyy.top/tags/npm/"}]},{"title":"pm2怎么指定master","date":"2017-08-08T06:59:46.000Z","path":"2017/08/08/7URpImMqF24g6oKs/","text":"node集群启动模式通常会这样写 123456789101112131415var cluster = require('cluster'); var http = require('http'); var os = require('os');var numCPUs = os.cpus().length;if(cluster.isMaster)&#123; for (var i = 0; i &lt; numCPUs; ++i) &#123; cluster.fork(); &#125;&#125; else &#123; http.createServer(function(req, res) &#123; res.writeHead(200); res.end(\"hello world\"); &#125;).listen(8080);&#125; 我们可以通过cluster.isMaster来执行一些任务;pm2是一个很好的nodejs 管理工具，我们可以通过配置来启动我们的nodejs服务，他的代码和我们平常写的一样。例如：123456var http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200); res.end(\"hello world\");&#125;).listen(8080); 但是我们想只在master上做一些任务，改怎么做呢？下面跟出一中方法：我们可以通过两个配置，分别指定不同的命令行参数来区别： 12345678910111213141516&#123; \"apps\" : [ &#123; \"name\": \"Master\", \"script\": \"app.js\", \"args\": [\"master\"], \"instances\": \"1\", &#125;, &#123; \"name\": \"Slave\", \"script\": \"app.js\", \"args\": [\"slave\"], \"instances\": \"-1\" &#125; ]&#125; 然后在app.js中这样写： 12345if (process.argv[2] === 'master')&#123; // ...&#125; else &#123; // ...&#125; 也可以通过其他环境变量参数来区分那个是master。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"pm2","slug":"pm2","permalink":"http://blog.cuiyy.top/tags/pm2/"}]},{"title":"搭建网盘服务器","date":"2017-07-18T02:00:11.000Z","path":"2017/07/18/YocazGnoJ07Z4rms/","text":"安装 Seafile 服务器安装依赖环境在 Debian/Ubuntu 系统下，可以使用以下命令安装 MySQL： 12sudo apt-get updatesudo apt-get install mysql-server 使用以下命令安装 Python 相关依赖： 1sudo apt-get install python2.7 python-setuptools python-imaging python-ldap python-mysqldb python-memcache python-urllib3 安装 MySQL 过程需要为 MySQL 的 root 用户设置新密码，请记住该[密码]以供后面步骤使用。 为 Seafile 创建一个用户创建 Seafile 用户，使用它运行 Seafile 服务： 1sudo useradd -m -s /bin/bash seafile 为该用户设置密码：1sudo passwd seafile 下载Seafile切换到新用户，需要输入你刚才为seafile用户设置的密码：1su - seafile 切换目录：1cd ~ 这里可以查看获取最新 Seafile 下载链接，参考以下命令进行下载。 1234wget http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.1.1_i386.tar.gz# 64位：# https://download.seadrive.org/seafile-server_6.1.1_x86-64.tar.gz 解压:12tar -xzf seafile-server_*mv seafile-server-*/ seafile-server/ 配置 Seafile运行Seafile设置脚本，并回答预设问题： 12cd seafile-server*./setup-seafile-mysql.sh 执行过程输入参数如下图：其中：[ This server’s ip or domain ] 字段输入服务器IP地址（111.111.111.111）。mysql 的 [ root password ] 字段输入数据库密码。其他字段一路回车使用默认值。 启动 Seafile12./seafile.sh start./seahub.sh start 执行过程输入参数如截图所示，其中 [ admin email ] 设置为您登录网盘的帐号，如 xxx@xxx.com[ admin password ] 和 [ admin password again ] 设置为登录网盘的密码，如 xxxxxxx 大功告成！恭喜，您的 Seafile 已经部署完成，您现在拥有专属的网盘了，登录的帐号密码为您启动 Seafile 步骤中设置的邮箱和密码。可以通过 IP 访问网盘：http://111.111.111.111:8000 注意安装过程中会出现类似错误error while loading shared libraries: libselinux.so.1: cannot open shared object file: No such file or directory 这是由于安装包与系统位不同导致的，64位系统要下载对应的64位的安装包","tags":[{"name":"网盘","slug":"网盘","permalink":"http://blog.cuiyy.top/tags/网盘/"}]},{"title":"搭建FTP服务器","date":"2017-07-17T12:10:11.000Z","path":"2017/07/17/5ykC26xyTqYUFCqG/","text":"安装并启动 FTP 服务安装 VSFTPD使用 apt-get 安装 vsftpd 1sudo apt-get install vsftpd -y 启动 VSFTPD安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经监听了 21 端口 1sudo netstat -nltp | grep 21 如果没有启动，可以手动开启 VSFTPD 服务： 1sudo systemctl start vsftpd.service 配置用户访问目录新建用户主目录1sudo mkdir /home/uftp 执行完后，在这里 /home/uftp 就能看到新建的文件夹 uftp 了。 创建登录欢迎文件1sudo touch /home/uftp/welcome.txt ###新建用户 uftp 并设置密码创建一个用户 uftp 1sudo useradd -d /home/uftp -s /bin/bash uftp 为用户 uftp 设置密码 1sudo passwd uftp 删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败： 1sudo rm /etc/pam.d/vsftpd 限制该用户仅能通过 FTP 访问限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器： 1sudo usermod -s /sbin/nologin uftp 修改 vsftpd 配置 1sudo chmod a+w /etc/vsftpd.conf 修改 /etc/vsftpd.conf 文件中的配置（直接将如下配置添加到配置文件最下方）： 123456789101112131415161718# 限制用户对主目录以外目录访问chroot_local_user=YES# 指定一个 userlist 存放允许访问 ftp 的用户列表userlist_deny=NOuserlist_enable=YES# 记录允许访问 ftp 用户列表userlist_file=/etc/vsftpd.user_list# 不配置可能导致莫名的530问题seccomp_sandbox=NO# 允许文件上传write_enable=YES# 使用utf8编码utf8_filesystem=YES 新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户：12sudo touch /etc/vsftpd.user_listsudo chmod a+w /etc/vsftpd.user_list 修改 /etc/vsftpd.user_list ，加入刚刚创建的用户： 12vsftpd.user_listuftp 设置访问权限设置主目录访问权限（只读）1sudo chmod a-w /home/uftp 新建公共目录，并设置权限（读写）1sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public 重启vsftpd 服务：1sudo systemctl restart vsftpd.service 访问 FTP 服务FTP 服务已安装并配置完成，下面我们来使用该 FTP 服务访问 FTP 服务根据您个人的工作环境，选择一种方式来访问已经搭建的 FTP 服务 ###通过 FTP 客户端工具访问FTP 客户端工具众多，下面推荐两个常用的：FileZilla - 跨平台的 FTP 客户端，支持 Windows 和 MacWinSCP - Windows 下的 FTP 和 SFTP 连接客户端下载和安装 FTP 客户端后，使用下面的凭据进行连接即可：主机 111.111.111.11用户：uftp 输入密码后，如果能够正常连接，那么大功告成，您可以开始使用属于您自己的 FTP 服务器了！接下来，请上传任意一张图片到您的 FTP 服务器上的 uftp 的 public 目录下，然后，就可以在 /home/uftp/public 中看到了。 ###通过 Windows 资源管理器访问Windows 用户可以复制下面的链接到资源管理器的地址栏访问： 1ftp://uftp:你的密码@111.111.111.11","tags":[{"name":"FTP","slug":"FTP","permalink":"http://blog.cuiyy.top/tags/FTP/"}]},{"title":"Vue.js 简单的拖拽排序组件","date":"2017-06-27T12:10:11.000Z","path":"2017/06/27/JQeeQ6YFw3kcrMxh/","text":"需求描述拖动属性及拖动事件接收默认数据拖动重新排序修改原始数据","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://blog.cuiyy.top/tags/Vue-js/"}]},{"title":"nodejs http.request 设置超时","date":"2017-06-23T13:19:11.000Z","path":"2017/06/23/ujZ8WMuDA7TISLvv/","text":"使用nodejs在请求第三方接口的时候，经常会用到http.request()方法；为了防止请求等待时间过长，我们可以为其设置超时时间。在请求参数中添加timeout参数例如： 1234567891011121314151617181920212223var http = require('http');var options = &#123; hostname: '127.0.0', port: 8080, path: '/x', method: 'GET', timeout: 500&#125;var req = http.request(options, function (res) &#123; res.on('data', function (chunk) &#123; console.log('BODY: ' + chunk); &#125;); res.on('end', function (error) &#123; console.log('请求完成'); &#125;); res.on('timeout', function() &#123; console.log('请求超时'); &#125;);&#125;);req.on('error', function(e) &#123; console.log('请求失败: ' + e.message); &#125;);req.end(); 请求超过500毫秒后，会终止请求，同时触发timeout事件，我们可以监听此事件，在请求超时后做一些处理。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"http","slug":"http","permalink":"http://blog.cuiyy.top/tags/http/"}]},{"title":"browsersync 省时的浏览器同步测试工具","date":"2017-06-23T01:58:32.000Z","path":"2017/06/23/Tve7kc4flBoVIhdF/","text":"Browsersync能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试。您可以想象一下：“假设您的桌子上有pc、ipad、iphone、android等设备，同时打开了您需要调试的页面，当您使用browsersync后，您的任何一次代码保存，以上的设备都会同时显示您的改动”。无论您是前端还是后端工程师，使用它将提高您30%的工作效率。 安装安装nodejs安装browsersync1npm install -g browser-sync 启动 BrowserSync静态网站如果您想要监听.css文件, 您需要使用服务器模式。 BrowserSync 将启动一个小型服务器，并提供一个URL来查看您的网站。1browser-sync start --server --files \"css/*.css\" --files 路径是相对于运行该命令的项目（目录） 如果您需要监听多个类型的文件，您只需要用逗号隔开。例如我们再加入一个.html文件 1234# --files 路径是相对于运行该命令的项目（目录） browser-sync start --server --files \"css/*.css, *.html\"# 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。 browser-sync start --server --files \"**/*.css, **/*.html\" 动态网站如果您已经有其他本地服务器环境PHP或类似的，您需要使用代理模式。 BrowserSync将通过代理URL(localhost:3000)来查看您的网站。 123# 主机名可以是ip或域名# --port 指定代理端口browser-sync start --proxy \"127.0.0.1:8080\" --port 3001 --files \"css/*.css\"","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"自动化","slug":"自动化","permalink":"http://blog.cuiyy.top/tags/自动化/"}]},{"title":"nodemon","date":"2017-06-20T08:40:13.000Z","path":"2017/06/20/Ga3g8f89sQ1zEnJ9/","text":"nodemon将监视启动nodemon的目录中的文件，如果任何文件更改，nodemon将自动重新启动node应用程序。 安装1npm install -g nodemon 用法1nodemon [your node app] 使用nodemon很简单，如果我的应用程序接受主机和端口作为参数，可以这样使用: 1nodemon ./server.js localhost 8080 nodemon还支持运行和监视coffee脚本应用程序： 1nodemon server.coffee 启用调试 1nodemon --debug ./server.js 80","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"自动化","slug":"自动化","permalink":"http://blog.cuiyy.top/tags/自动化/"}]},{"title":"yarn 快速、可靠、安全的依赖管理","date":"2017-06-20T03:35:25.000Z","path":"2017/06/20/Eyvj2n2bqaRnQFDq/","text":"yarn是类似于npm的包管理工具，相比npm,速度更快，更安全可靠。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"工具","slug":"工具","permalink":"http://blog.cuiyy.top/tags/工具/"}]},{"title":"Ubuntu 16 安装mongodb","date":"2017-05-02T02:58:36.000Z","path":"2017/05/02/gKAfWgqGd2uDqcHZ/","text":"通过apt-get安装软件包签名验证Ubuntu软件包管理工具（即dpkg和apt）通过要求分销商使用GPG密钥对软件包进行签名来确保软件包的一致性和真实性。1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 官方文档 为MongoDB创建一个列表文件1echo \"deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list 更新本地包数据1sudo apt-get update 安装MongoDB包1sudo apt-get install -y mongodb-org 启动|暂停|重启123sudo service mongod startsudo service mongod stopsudo service mongod restart 手动安装下载安装包1wget https://fastdl.mongodb.org/linux/mongodb-linux-arm64-ubuntu1604-3.4.4.tgz 解压1tar -xzvf mongodb-linux-arm64-ubuntu1604-3.4.4.tgz 编写Ubuntu服务文件增加/lib/systemd/system/mongod.service文件 12345678910[Unit]Description=An object/document-oriented databaseDocumentation=man:mongod(1)[Service]User=rootExecStart=/mongodb/bin/mongod --quiet --config /mongodb/mongodb.conf[Install]WantedBy=multi-user.target 重新加载service文件1systemctl daemon-reload 启动|暂停|重启123sudo service mongod startsudo service mongod stopsudo service mongod restart","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.cuiyy.top/tags/mongodb/"},{"name":"Ubuntu16","slug":"Ubuntu16","permalink":"http://blog.cuiyy.top/tags/Ubuntu16/"}]}]