[{"title":"Docker常用命令","date":"2018-03-22T07:51:56.000Z","path":"2018/03/22/S9W5DqMr7gXmcx62/","text":"图片 镜像常用操作1、列出镜像1docker images 2、拉取镜像1docker pull node:8.10.0 3、搜索镜像1docker search node 4、导出导入镜像12docker save node &gt; node.tardocker load &lt; node.tar Docker容器常用操作1、创建并启动容器1docker run -i -t node /bin/bash -i启动容器后打开标准输入-t分配一个终端，与服务器建立一个会话 2、列出容器1docker ps 3、进入运行中的容器1docker attach 容器ID 4、执行命令1docker exec -i -t 容器ID ls -l 5、停止容器1docker stop 容器ID 6、终止容器1docker kill 容器ID 7、启动容器1docker start 容器ID 8、重启容器1docker restart 容器ID 9、删除容器1docker rm 容器ID 10、导入导出容器12docker export 容器ID &gt; node.tardocker import node.tar cyy/node:latest —-publish by CEditor","tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.cuiyy.top/tags/Docker/"}]},{"title":"Dockerfile格式","date":"2018-03-22T07:51:42.000Z","path":"2018/03/22/H1bYYa2NHIsHPdqb/","text":"图片 Dockerfile是用于构建Docker镜像的脚本文件。 1234567891011121314151617181920212223242526272829303132333435363738# 基础镜像FROM node:8.9.4# 维护者信息，旧版本写法不一样LABEL maintainer=\"cyy\"# 工作目录WORKDIR /api# 复制本地文件到容器中COPY ./package.json /hk-ad-api/# 在终端执行命令RUN npm install --production --registry=https://registry.npm.taobao.orgRUN \\ rm /etc/localtime &amp;&amp; \\ ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# 容器暴露端口号EXPOSE 6080# 环境变量ENV NODE_ENV=\"production\" \\ MONGO_HOST= \\ MONGO_OPTION= \\ MONGO_PORT= \\ MONGO_USER=\\ MONGO_PASSWD=\\ REDIS_HOST= \\ REDIS_PASSWD=\\ REDIS_PORT=\\ MEMCACHE_HOST=\\ MEMCACHE_USERNAME=\\ MEMCACHE_PASSWORD=\\ MEMCACHE_PORT=\\ MYSQL_HOST='' \\ MYSQL_PORT=\\ MYSQL_USER=\\ MYSQL_PASSWD=\\ PORT=6080# 类似COPYADD . /api# 容器执行的命令，每个容器只能执行一条CMD命令CMD [\"node\", \"www/production.js\"] —-publish by CEditor","tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.cuiyy.top/tags/Docker/"}]},{"title":"Vuex 引入多个模块简写方法","date":"2018-01-23T06:19:01.000Z","path":"2018/01/23/EWvgtanU7ttog24A/","text":"在使用Vuex对vue项目进行状态管理时，我们的Vuex主文件通常是这个样子的： 123456789101112import Vue from 'vue'import Vuex from 'vuex'import A from './modules/a'import B from './modules/b'Vue.use(Vuex)export default new Vuex.Store(&#123; modules: &#123; A, B &#125;, strict: true&#125;) 随着项目变得越来越大，我们导入的文件就会越来越多，而且有时候在modules文件夹下添加了文件后，会忘了在主文件中添加进去；有没有自动导入的方法呢？ 在webpack中，有提到一个方法require.context；可以使用此方法来创建自己的（模块）上下文，它接收三个参数： 要搜索的文件夹目录 是否还应该搜索它的子目录 以及一个匹配文件的正则表达式 例如： 1234require.context(\"./test\", false, /\\.test\\.js$/);// （创建了）一个包含了 test 文件夹（不包含子目录）// 下面的、所有文件名以 `.test.js` 结尾的、// 能被 require 请求到的文件的上下文。 详细请查看require.context的文档。 我们可以使用此方法来修改我们的代码；修改后如下： 12345678910111213import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)let ms = require.context('./modules', false, /\\.js$/)let modules = &#123;&#125;ms.keys().forEach(k =&gt; &#123; let n = k.substring(2, k.length - 3) modules[n] = ms(k).default&#125;)export default new Vuex.Store(&#123; modules, strict: true&#125;) 此时，在modules中添加的所有以.js后缀结尾的文件都会被自动导入进来了。 —-publish by CEditor","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://blog.cuiyy.top/tags/Vue-js/"},{"name":"webpack","slug":"webpack","permalink":"http://blog.cuiyy.top/tags/webpack/"}]},{"title":"如何免费科学上网","date":"2018-01-16T06:03:15.000Z","path":"2018/01/16/71hYzzWl30Ec9OZh/","text":"如何使用免费资源实现科学上网？首先要有一台可以访问墙外资源的服务器，然后在服务器上搭建shadowsocks即可。 本教程开始前，请确保您的电脑可以访问google网站。（WTF！！） 领取免费资源Google Cloud Platform 免费方案 goole提供12个月及$300美金的赠金，登录即可领取。 搭建服务器登录Google Cloud Platform创建项目，然后打开左侧菜单，选择Compute Engine，创建一个VM实例,根据提示完成创建。 创建完成后，点击链接SSH登录远程服务器。 安装 shadowsocks 服务程序打开Shadowsocks servers,根据提示安装。 12apt-get install python-pippip install shadowsocks 配置文件创建一个配置文件conf.json 123456789&#123; \"server\":\"内网ip\", \"server_port\":8388, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"password\", \"timeout\":300, \"method\":\"aes-256-cfb\"&#125; 注意：server一定要是服务器的内网ip，使用外网ip可以请求不通。 启动及停止1sudo ssserver -c ./conf.json -d start 停止将start改成stop即可。 查看日志1sudo less /var/log/shadowsocks.log 常见错误启动错误 客户端连接客户端下载GitHub上下载 填写外网地址，选择加密方式，输入密码，确定后链接即可。 —-publish by CEditor","tags":[{"name":" 工具","slug":"工具","permalink":"http://blog.cuiyy.top/tags/工具/"}]},{"title":"广告竞价中常用的价格解密算法","date":"2018-01-10T06:41:15.000Z","path":"2018/01/10/RaSYFZPT0VuWlkVp/","text":"Real-Time Bidding Protocol Decrypt Price Confirmations 谷歌实时竞价文档 加密结果格式1&#123;初始化向量 (16 bytes)&#125;&#123;加密的价格(8 bytes)&#125;&#123;完整性签名(4 bytes)&#125; 加密价格的长度固定为 28 个字节，其中包含 16 个字节的初始化矢量、8 个字节的密 文以及 4 个字节的完整性签名。 加密方式使用基于SHA-1 HMAC算法的加密解密示例如下:加密阶段伪代码:1234pad = hmac(e_key, iv) // 取前 8 个字节 enc_price = pad &lt;xor&gt; pricesignature = hmac(i_key, price || iv) // 取前 4 个字节final_message = WebSafeBase64Encode( iv || enc_price || signature ) 解密阶段伪代码12345(iv || enc_price || signature) = WebSafeBase64Decode(final_message) pad = hmac(e_key, iv)price = enc_price &lt;xor&gt; padconf_sig = hmac(i_key, price || iv)success = (conf_sig == signature) 字符与表达式解释iv: 初始化矢量(16 个字节)e_key: 加密密钥(32 个字节)i_key: 完整性密钥(32 个字节)price: 价格 (8 个字节)hmac(k, d): 数据 d 的 SHA-1 HMAC，使用密钥 ka || b: 字符串 a 和字符串 b 并列 解密算法nodejs版示例12345678910111213141516171819202122232425262728293031323334353637const crypto = require('crypto');const e_key = \"\";const i_key = \"\";function WebSafeBase64Decode(base) &#123; var s = base.replace(/\\-/g, '+').replace(/\\_/g, '/'); if ((s.length % 4) == 2) &#123; s += \"==\"; &#125; else if ((s.length % 4) == 3) &#123; s += \"=\"; &#125; return s;&#125;function decodePrice(e_enc) &#123; let buffer = new Buffer(WebSafeBase64Decode(e_enc), 'base64'); // base64解码 let iv = buffer.slice(0, 16); // 初始化矢量数组 let en_price = buffer.slice(16, 24); // 加密的价格数组 let integrity = buffer.slice(24, 28).toString('hex'); // 完整性签名的前4位, 转换成16进制字符串 let de_byte = crypto.createHmac('sha1', e_key).update(iv).digest().slice(0, 8); // HmacSHA1 加密得到加密数组, 取前8个字节 let dec_price = new Buffer.allocUnsafe(8); // 创建一个长度为8的buffer for (let i = 0; i &lt; 8; i++) &#123; dec_price[i] = en_price[i] ^ de_byte[i] // 将异或运算后的新值存入dec_price &#125; let price = parseInt(dec_price.toString(\"hex\"), 16) / 1000000; // 转换成价格 // 加密签名验证 let o_ikey = crypto.createHmac('sha1', i_key).update(Buffer.concat([dec_price, iv])).digest().slice(0, 4).toString('hex'); if (integrity == o_ikey) &#123; // 比较两个签名数组是否相同 return price; &#125; else &#123; return -1; &#125;&#125;decodePrice(\"加密价格字符串\"); —-publish by CEditor","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"}]},{"title":"(二)ReactNative图标、app名称及启动页设置","date":"2017-12-18T02:39:35.000Z","path":"2017/12/18/6H6ccqstKfuW1iYe/","text":"修改App图标替换项目目录android\\app\\src\\main\\res\\mipmap-xxx中的图片即可 修改App名称打开项目目录android\\app\\src\\main\\res\\valuse\\strings.xml,修改即可：123&lt;resources&gt; &lt;string name=\"app_name\"&gt;名称&lt;/string&gt;&lt;/resources&gt; 设置启动页使用rn-splash-screen组件：使用方法：1、安装 npm i rn-splash-screen --save2、连接 react-native link rn-splash-screen3、在res文件中新建drawable文件夹，放置splash.png图片4、修改android/app/src/main/res/values/styles.xml文件，添加一行：123456789101112131415161718192021222324252627&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/splash&lt;/item&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt;&lt;/resources&gt;5.修改`android/app/src/main/AndroidManifest.xml`文件：```xml&lt;application android:name=\".MainApplication\" android:allowBackup=\"true\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\"&gt; &lt;activity android:name=\".MainActivity\" android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:configChanges=\"keyboard|keyboardHidden|orientation|screenSize\" android:windowSoftInputMode=\"adjustResize\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" /&gt; &lt;/application&gt; 6.修改android/app/src/main/java/com/APPNAMES/MainActivity.java文件： 12345678910111213141516import com.facebook.react.ReactActivity;import android.graphics.Color;import android.os.Bundle;import com.facebook.react.ReactInstanceManager;import com.facebook.react.bridge.ReactContext;import com.mehcode.reactnative.splashscreen.SplashScreen;public class MainActivity extends ReactActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // Show the js-controlled splash screen SplashScreen.show(this, getReactInstanceManager()); super.onCreate(savedInstanceState); &#125;&#125; 7.修改项目入口页面1234import SplashScreen from \"rn-splash-screen\";// Hide the active splash screenSplashScreen.hide(); 执行react-native run-android启动查看效果 —-publish by CEditor","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://blog.cuiyy.top/tags/React-Native/"}]},{"title":"(一)ReactNative环境搭建及项目创建","date":"2017-12-18T02:08:11.000Z","path":"2017/12/18/HEMuznW11H0mJepR/","text":"安装安装所需Xcode、Java、Android SDK、Android Studio、Nodejs、watchman安装Android 模拟器 安装React Native CLI1npm install -g react-native-cli 代码环境Visual Studio Code浏览器插件： ReactDev Tools 创建项目初始化项目123react-native init appcd appnpm install ##运行项目将手机用数据线链接或打开手机模拟器安卓手机输入adb devices，会列出设备在项目目录下输入1npm run android 等待完成后会在手机上打开app实例 启动调试工具如果是真机，可以摇晃手机，打开菜单，选择Debug JS Remotely;会在浏览器中打开http://localhost:19001/debugger-ui/页面。如果是模拟器启动，可以输入以下命令触发： 1adb shell input keyevent 82 —-publish by CEditor","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://blog.cuiyy.top/tags/React-Native/"}]},{"title":"Vue.js 简单的拖拽排序组件","date":"2017-11-15T03:24:00.000Z","path":"2017/11/15/JQeeQ6YFw3kcrMxh/","text":"演示地址 github —-publish by CEditor","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://blog.cuiyy.top/tags/Vue-js/"}]},{"title":"PM2+Log4js log写入失败问题","date":"2017-11-15T03:02:53.000Z","path":"2017/11/15/I4m5wYG9ovY6L9Va/","text":"问题：项目中用log4js可以正常写入日志到文件中，后来使用pm2启动后，发现文件不能写入到文件了。网上查了很久，并没有找到原因，所以就想到了查看源码的方法，来查找到底是哪里出了问题。 先看相关的配置log4js配置：1234567&#123; \"type\": \"dateFile\", \"filename\": \"logfile/\", \"pattern\": \"flow-yyyy-MM-dd-hh.log\", \"alwaysIncludePattern\": true, \"layout\": &#123; \"type\": \"messagePassThrough\" &#125;&#125; pm2配置：1234567891011121314151617181920212223242526&#123; \"apps\": [ &#123; \"name\": \"project_name\", \"script\": \"index.js\", \"exec_mode\": \"cluster\", \"instances\": 4, \"instance_var\": \"INSTANCE_ID\", \"max_memory_restart\": \"1G\", \"autorestart\": true, \"node_args\": [], \"watch\": [\"config\", \"data\", \"lib\",\"public\", \"index.js\"], \"watch_options\": &#123; \"usePolling\": true &#125;, \"args\": [], \"env\": &#123;&#125;, \"env_dev\": &#123; ... &#125;, \"env_production\": &#123; ... &#125; &#125; ]&#125; log4js无法自动生成对应时间格式的文件正常直接启动会在配置log目录下生成一个flow-yyyy-MM-dd-hh.log格式的文件，但是用pm2启动的时候并没有生成。 log4js的调用方法为require(&#39;log4js&#39;).getLogger(),所以就直接在源码中找getLogger：1、通过package.json中的main我们确定它的主入口文件为./lib/log4js；2、找到getLogger方法1234567891011/** * Get a logger instance. * @static * @param loggerCategoryName * @return &#123;Logger&#125; instance of logger for the category */function getLogger(category) &#123; const cat = category || 'default'; debug(`creating logger as $&#123;isMaster() ? 'master' : 'worker'&#125;`); return new Logger((isMaster() ? sendLogEventToAppender : workerDispatch), cat);&#125; 其中有个isMaster()方法,判断是否为主进程1234567function isPM2Master() &#123; return config.pm2 &amp;&amp; process.env[config.pm2InstanceVar] === '0';&#125;function isMaster() &#123; return config.disableClustering || cluster.isMaster || isPM2Master();&#125; 可以看到isPM2Master是通过config中的pm2参数和pm2InstanceVar来确定的。所以我们需要在log4js的配置中增加这两个配置。1234&#123; pm2: true, pm2InstanceVar: \"INSTANCE_ID\" // 与pm2的配置对应 &#125; pm2 中NODE_APP_INSTANCE 特定的环境变量可以用来判断主从进程 此时重启pm2后(需要pm2 delete不然pm2配置文件不生效)，已经可以看到生成的文件了，但是日志还是不能写入。接着看源码： workerDispatch方法1234function workerDispatch(logEvent) &#123; debug(`sending message to master from worker $&#123;process.pid&#125;`); process.send(&#123; topic: 'log4js:message', data: serialise(logEvent) &#125;);&#125; 此方法为工作进程接收到log事件，并发出消息，必定有接收的地方，通过查找代码发现此方法:1234567891011121314151617181920function configure(configurationFileOrObject) &#123; // ... if (config.disableClustering) &#123; debug('Not listening for cluster messages, because clustering disabled.'); &#125; else &#123; // PM2 cluster support // PM2 runs everything as workers - install pm2-intercom for this to work. // we only want one of the app instances to write logs if (isPM2Master()) &#123; debug('listening for PM2 broadcast messages'); process.removeListener('message', receiver); process.on('message', receiver); &#125; else if (cluster.isMaster) &#123; debug('listening for cluster messages'); cluster.removeListener('message', receiver); cluster.on('message', receiver); &#125; else &#123; debug('not listening for messages, because we are not a master process'); &#125; &#125; 我们可以看到在if条件中有监听的操作，但是，后面的监听函数没有执行，后来才注意到里面的三行注释，需要安装pm2-intercom;在执行了pm2 install pm2-intercom后，果然可以了，日志成功写入到了文件中。 —-publish by CEditor","tags":[{"name":"log4js","slug":"log4js","permalink":"http://blog.cuiyy.top/tags/log4js/"},{"name":" pm2","slug":"pm2","permalink":"http://blog.cuiyy.top/tags/pm2/"}]},{"title":"TypeError The header content contains invalid characters","date":"2017-11-04T07:56:42.000Z","path":"2017/11/04/T7ildrYrjZMrsfzN/","text":"nodejs运行过程中出现此错误 1TypeError: The header content contains invalid characters 出现此原因发现是在执行ctx.redirect 的时候出现的，经检查发现为redirect的url中包含了中文，修改为redirect(encodeURI(url))即可。 —-publish by CEditor","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":" http","slug":"http","permalink":"http://blog.cuiyy.top/tags/http/"}]},{"title":"Pow 快速创建静态网页服务器","date":"2017-10-20T07:36:23.000Z","path":"2017/10/20/IhU1Rkv60ls2ja09/","text":"Pow是Mac OS X的零配置机架式服务器。 安装Pow需要Mac OS X 10.9或更高版本。要安装或升级Pow，只需打开终端并运行以下命令 1curl get.pow.cx | sh 使用只需将静态文件目录链接到您的~/.pow 目录中即可。假设你有个应用程序放在 ~/Projects/myapp中，并且包含了public目录，你想要这样访问它 http://myapp.dev/；可以这样设置： 12cd ~/.powln -s ~/Projects/myapp 如果您有一个静态站点，并希望将文件保留在项目的根目录中（即不在 public目录中），则可以执行以下操作： 1234cd ~/.powmkdir your-app-domaincd !$ln -s ~/Projects/your-app public —-publish by CEditor","tags":[{"name":" 工具","slug":"工具","permalink":"http://blog.cuiyy.top/tags/工具/"}]},{"title":"前端mac系统重装之后","date":"2017-10-17T10:20:50.000Z","path":"2017/10/17/etb9IVimFgncBxLQ/","text":"最近刚更新了 macOS High Sierra，更新过程非常坎坷，最后终于安装成功了，但是曾经装的软件什么的都没有了，需要重新安装，这里列出我所安装的软件列表： 系统常用 chrome浏览器 百度输入法 Magnet 分屏软件 iPic 图片上传神器 全能解压 Alfred Sip 拾色工具 1Password 社交 微信 qq 钉钉 写作笔记 有道云笔记 印象笔记 编辑器 Sublime Text 3 (package control) VScode Shell增强 oh my zsh Homebrew wget (brew install wget) autojump (brew install autojump)如果link失败可执行 1sudo chown -R $(whoami) /usr/local/share/ 代码管理 Git生成KEY：123git config --global user.name “xx”git config --global user.email “x@gmail.com\"ssh-keygen -t rsa -C “xx@gmail.com” 开发相关 Nodejs nodemon (npm install -g nodemon) node更改自动重启 yarn （node包管理） cnpm 淘宝 NPM 镜像 1npm install -g cnpm --registry=https://registry.npm.taobao.org Mongodb MySQL Robo 3T mongo客户端 Navicat for mysql MySQL客户端 Redis RedisDesktopManager Redis客户端 Memcached 缓存管理 其他 Scss 前端CSS扩展语言 vim 设置123vim ~/.zshrcsyntax onset nu # 显示行号 —-publish by CEditor","tags":[{"name":" 工具","slug":"工具","permalink":"http://blog.cuiyy.top/tags/工具/"}]},{"title":"Weex 项目 Android部署","date":"2017-10-16T09:52:41.000Z","path":"2017/10/16/0ySGeMATlDSbikLM/","text":"环境要求1、安装 Android Studio或者 Android SDK 2、 安装 Android SDK Build-Tools 23.0.2版本 打开Android Studio&gt;Tools&gt;Android&gt;SDK Manager，选择SDK Tools选项， 选择Show Package Details; 找到 23.0.2勾选并安装。 3、配置环境变量,执行vim ~/.bash_profile 增加如下代码：123export ANDROID_HOME=/Users/you/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools 保存后执行resource ~/.bash_profile,使修改生效；如果你用了其他终端，如『zsh』，可将 . ~/.bash_profile命令添加到~/.zshrc中； jdk 安装下载安装jdk 8，如果安装了9版本会在运行时，出现编译失败问题，如下图： 如果需要多个jdk版本可添加别名，实现快速切换使用；可在.bash_profile中增加如下代码1234export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`export JAVA_9_HOME=`/usr/libexec/java_home -v 9`alias jdk8=\"export JAVA_HOME=$JAVA_8_HOME\"alias jdk9=\"export JAVA_HOME=$JAVA_9_HOME\" 此时可通过jdk8、jdk9随意切换版本。 运行一切准备就绪后在终端运行以下命令，增加安卓端支持：12weex platform add androidweex run android 运行过程中会下载一堆的jar包；并会出现以下错误： 提示缺少安卓设备，我们可以在Android Studio中设置虚拟机，也可以用USB连接安卓手机，并打开调试模式，然后重新执行weex run android; 如果运行成功，可在手机上看到生成的程序，并自动打开。 注：有些手机可能会有一些权限问题导致不能自动安装成功，需要响应的设置才行。 —-publish by CEditor","tags":[{"name":"weex","slug":"weex","permalink":"http://blog.cuiyy.top/tags/weex/"}]},{"title":"MongoDB开启权限验证的方法","date":"2017-10-13T03:40:10.000Z","path":"2017/10/13/O74WjrqshGRNERf1/","text":"基本角色 root 这是超级管理员 userAdminAnyDatabase 这个角色拥有分配角色和用户的权限，但没有查写的权限 readWrite 有读写权限 read 有读权限 创建一个超级用户123456789use admindb.createUser(&#123; user: \"root\", pwd: \"cyy_mongo\", roles: [&#123; \"role\" : \"root\", \"db\" : \"admin\" &#125;]&#125;) db是指定数据库的名字，admin是管理数据库。 开启认证进入mongod.conf配置文件，将auth 改为true；重启mongo服务； 权限登录1mongo --host xxx -u adminUserName -p userPassword --authenticationDatabase admin 其他查看当前用户的权限1234db.runCommand(&#123; usersInfo:\"userName\", showPrivileges:true&#125;) 创建一般用户，也是用createUser123456789db.createUser(&#123; user:\"user1\", pwd:\"12345\", roles:[ &#123;role:\"read\",db:\"db1\"&#125;, &#123;role:\"read\",db:\"db2\"&#125;, &#123;role:\"read\",db:\"db3\"&#125; ]&#125;) 修改密码12use admindb.changeUserPassword(\"username\", \"xxx\") 查看用户信息1db.runCommand(&#123;usersInfo:\"userName\"&#125;) 修改密码和用户信息12345db.runCommand(&#123; updateUser:\"username\", pwd:\"xxx\", customData:&#123;title:\"xxx\"&#125;&#125;) —-publish by CEditor","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.cuiyy.top/tags/mongodb/"}]},{"title":"为了遇见你","date":"2017-10-12T07:17:52.000Z","path":"2017/10/12/dVIMLDDUxriU57uW/","text":"—-publish by CEditor","tags":[{"name":"其他","slug":"其他","permalink":"http://blog.cuiyy.top/tags/其他/"}]},{"title":"ssh 免密码登录","date":"2017-10-10T05:00:31.000Z","path":"2017/10/10/Ja5aO9RFlMdvjYBE/","text":"开发过程中，经常需要使用ssh登录远程主机，每次都要输入密码，影响效率，这里讲解一下，怎么使用ssh无密码登录。 本机生成ssh keyssh 无密码登录要使用公钥与私钥。linux下可以用用ssh-keygen生成公钥/私钥对。 1ssh-keygen -t rsa -C \"xxx@email.com\" 然后一路回车即可。 然后可以通过以下命令查看到生成的公钥： 1cat ~/.ssh/id_rsa.pub 远程主机生成ssh key先通过ssh登录到远程主机， 并以同样的方式生成ssh key 复制本机公钥到远程文件把本地的id_rsa.pub文件中的内容复制到远程主机的.ssh/authorized_keys文件里. authorized_keys文件如果没有，可以自己手动创建。 添加完成后，退出重新使用ssh 登录时，就不需要输入密码了。","tags":[{"name":"ssh","slug":"ssh","permalink":"http://blog.cuiyy.top/tags/ssh/"}]},{"title":"nodejs使用socket.io实现分布式一对一发送消息","date":"2017-09-27T09:13:53.000Z","path":"2017/09/27/QkkxF6N8eMj7mVKX/","text":"最近在用nodejs实现一个消息通知的功能，其中用到了socket.io；由于初次使用socket.io，在网上查找资料大都是聊天室广播的教程，没有找到一对一发送消息的具体实现方法，这里分享一下自己学习使用过程中踩到某些坑和最终实现方法。 要实现的功能:server端数据更新后，发送通知到对应客户端的用户；server是用nodejs写的，并使用了分布式，同时开启了多个实例。 一、安装依赖包 1npm install socket.io 二、socket.io的使用1、index.js 文件内容 12345678//index.jsvar express = require('express');var app = express();var server = require('http').Server(app);var io = require('socket.io')(server,&#123; \"path\":\"/notice\" //修改客户端请求的路径，默认为/socket.io&#125;);new (require(\"./notice\").init)(io); //传入io 2、notice.js文件内容 1234567891011121314151617181920212223242526272829303132333435var Notice = null; var socketMap = &#123;&#125;; //用户对应socket.id//初始化socket连接exports.init = function (io)&#123; //连接验证 io.use(function(socket, next)&#123; //console.log(socket.request.headers.cookie); var token = socket.request._query.token || \"\"; if(validate(token))&#123; socket.request.headers.user = &#123;userId:userId&#125;; return next(); &#125;else&#123; return next(new Error('Authentication error')); &#125; &#125;); Notice = io.of(\"/notice\").on('connection', function(socket) &#123; var user = socket.handshake.headers.user; var user_id = user &amp;&amp; user.userId; if(user_id)&#123; socketMap[user_id] = socket.id; &#125; socket.on('disconnect', function() &#123; delete socketMap[user_id]; &#125;); &#125;);&#125;//其他模块调用，发送消息exports.send = function(data)&#123; var user_id = data.accountID; var socket_id = socketMap[user_id]; Notice.to(socket_id).emit('notice', data);&#125; 3、客户端文件 1234567&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io('http://localhost?token=token'); socket.on('notice', function (data) &#123; console.log(data); &#125;);&lt;/script&gt; 在跨域请求的情况下socket.request.headers.cookie是无法获取到有效的cookie的，所以这里直接从客户端传token过来进行验证。验证通过后，将用户信息存到headers中，客户端连接成功后，取出用户信息，并将用户id与此socket连接对应id存储到全局socketMap变量中，然后外部模块通过调用send方法来发送消息。 这种情况在单实例情况下是没有问题的，但是如果server开启了多个实例就出问题了。 三、使用nginx实现分布式部署首先需要安装nginx；安装完成后编写配置文件； 123456789101112131415161718upstream socket_test &#123; ip_hash; server 127.0.0.1:8013; server 127.0.0.1:8014;&#125;server &#123; listen 80; server_name socket.test.com; location / &#123; proxy_pass http://socket_test/; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 启动两个项目实例，分别监听8013和8014端口；然后启动nginx 1sudo nginx 通过测试会发现，消息有时候能收到，有时候收不到。原因是因为客户端请求的时候，会不定的请求服务端两个实例中的一个，如果连接的时候是请求的8013端口的实例，二发送消息是8014端口的实例 ，就会在8014的实例中找不到建立连接的socket。 四、分布式解决方法socket.io官网中提供了使用socket.io-redis来解决此方法；socket.io-redis中使用了redis的消息订阅与发布的功能，当有通知发送的时候，会触发onmessage事件，然后会调用broadcast广播。 接下来将socket.io-redis添加到index.js文件中 12345678910 //index.jsvar express = require('express');var app = express();var server = require('http').Server(app);var io = require('socket.io')(server,&#123; \"path\":\"/notice\" //修改客户端请求的路径，默认为/socket.io&#125;);new (require(\"./notice\").init)(io); //传入iovar redis = require('socket.io-redis');io.adapter(redis(&#123; host: settings.REDIS_HOST, port: settings.REDIS_PORT &#125;)); 然后重启后会发现还是不行，原因是因为在socketMap变量中有时候就找不到对应的user_id;因为是分布式的，所有socketMap变量在两台实例中并不是共享的，所以这里使用redis，在socket建立的时候将user_id对应的socket_id存储到redis中，发送消息的时候从redis中读取socket_id这样就可以了。 有时候一个用户可能会同时有多个socket连接，所以user_id对应的socket_id就可以是一个数组，发送消息的时候要循环发送，连接断开的时候要只删除对应的socket_id,保留其他建立的连接。 另外服务器重启时socket会重新建立连接，所以在初始化的的时候要清空redis中所有存储的数据。 —-publish by CEditor","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"socket.io","slug":"socket-io","permalink":"http://blog.cuiyy.top/tags/socket-io/"}]},{"title":"GitHub webhooks实现自动部署","date":"2017-09-27T03:33:39.000Z","path":"2017/09/27/pM6JLsCa29henIyW/","text":"使用第三方Git仓库，实现代码的自动部署GitHub 提供了Webhooks的功能，我们通过相应的配置就可以实现在代码提交到GitHub后自动部署我们的项目 在GitHub添加部署服务器的ssh key1、首先在服务器生成ssh key2、添加ssh key到GitHub账户中 选择setting -&gt; SSH and GPG keys -&gt; New SSH Key 添加 配置Webhooks打开需要配置Webhooks的项目，点击Settings，选择Webhooks Webhooks 设置 设置触发事件后请求的地址及方法，并选择触发事件的类型，此处选择为push,当我们提交代码的时候触发；设置完成后，点击添加即可。 服务器编辑接受处理代码以nodejs 的 express为例： 1234567891011121314151617181920var shell = require('shelljs'); // shell npm 包工具var setting = require('../setting');var blogPath = setting.blog.path;module.exports = function (req, res) &#123; var body = req.body; console.log(body) // git 推送的数据 if (!shell.which('git')) &#123; // 判断是否存在git命令 shell.echo('Sorry, this script requires git'); shell.exit(1); &#125; var cd = shell.cd(blogPath); if (!cd.code)&#123; // 执行git代码拉取操作 if (shell.exec('git pull origin master').code !== 0) &#123; shell.echo('Error: Git pull error!'); shell.exit(1); &#125; &#125; res.end();&#125; —-publish by CEditor","tags":[{"name":"Git","slug":"Git","permalink":"http://blog.cuiyy.top/tags/Git/"},{"name":"webhooks","slug":"webhooks","permalink":"http://blog.cuiyy.top/tags/webhooks/"}]},{"title":"让你备受刮目相看的8个npm技巧","date":"2017-09-27T02:26:54.000Z","path":"2017/09/27/dp034EZKdW2mePbk/","text":"本文转载自：众成翻译译者：liuhui_is_me链接：http://www.zcfy.cc/article/3362原文：https://medium.freecodecamp.com/8-npm-tricks-you-can-use-to-impress-your-colleagues-dbdae1ef5f9e 你观看一个同事编码时候，你会看到一些速记和技巧被应用，有些方式你并不熟悉，那你就被鄙视了，这种事情在我们每一个一生都会发生的。 在这篇文章中，我将介绍一些很有用的npm技巧，还有很多这里并不能全收录，我们只关注那些相关的并且有益于我们每天的工作和开发的技巧。 基本的速记为了让大家的对npm有一个一致的理解，尤其是我们的新人，让我们快速了解基本的速记和确保没有错过任何细节。 安装安装包常规: npm install pkg, 速记: npm i pkg. 全局安装包:常规: npm i --global pkg, 速记: npm i -g pkg. 安装包并包含在依赖中:常规: npm i --save pkg, 速记: npm i -S pkg. 安装包并包含在开发依赖中:常规: npm i --save-dev pkg, 速记: npm i -D pkg. 其他的npm速记阅读npm博客 速记表. 下面开始有趣的内容。 1. 初始化一个新包我们都知道npm init，用来创建一个新的包。 但是，所有的问题都是匿名的，我们无论如何都会修改它的，那么怎么避免发生呢？ 使用npm init -y 和 npm init -f回到初始化！ 2. 运行测试命令另一个命令就是npm test,我们可能每天使用依次或者一天使用好几次。 如果我告诉你可以使用少于40%的字符去完成这个功能？我们经常使用，应该这样。 幸运的是，我们可以使用npm t，它就可以胜任 3. 枚举可用的脚本我们开始一个新项目，我们想知道如何开始。我们通常会问自己这样的问题：我们如何运行它？哪些脚本可用？ 一个方法是打开package.json文件并检查scripts部分。 我们可以做的更好，当然，我们只是运行npm run得到一个的所有可用的脚本的列表。 另外的可以选择是安装ntl (npm i -g ntl)，然后运行ntl在项目文件夹中。它也可以运行脚本，也很方面。 4. 枚举已经安装的包类似于可用的脚本，有时我们会问自己我们的项目中有哪些依赖项。 我们可以再次打开package.json文件和检查，但是我们已经做的更好了。 使用 npm ls --depth 0. 枚举全局安装包，使用npm ls -g --depth 0 5. 运行本地安装的可执行文件我们安装了一个包在我们的项目中，它是一个可执行的，但我们只能运行它通过一个新的脚本。你想知道为什么，或者如何克服它？ 首先，让我们了解为什么——当我们在终端中执行命令时，实际发生的是它在PATH环境变量中列出的所有路径中查找一个具有相同名称的可执行文件。这就是他们如何神奇地从任何地方都可以执行。本地安装的软件包登记他们的可执行文件在本地，所以他们不在我们的PATH路径中将不会被发现。 当我们运行这些可执行文件通过一个新脚本，它是如何工作的呢？你可能会问？很好的问题！这是因为这种方式运行时，NPM做了一点技巧和增加了一个额外的文件夹到PATH，/node_modules/.bin中。你可以看到它的运行npm run env | grep &quot;$PATH&quot;。你也可以运行只是npm run env 查看所有可用的环境变量，npm增加了一些更有趣的东西。/node_modules/.bin，如果你不知道，正是在本地安装的软件包放置可执行文件的地方。 我们可以运行 ./node_modules/.bin/mocha 在我们的项目中，看看将会发生什么. 很简单, 对吧? 仅仅运行 ./node_modules/.bin/ ，无论什么时候你想要运行本地已安装的可执行文件。 6. 在网上查找你想要的包你可能看到了repository这个入口在package.json文件中，疑问“这有什么好处？” 为了问答这个问题，仅仅运行npm repo然后在你的浏览器中查看。 与之类似,npm home命令进入主页。 如果你想打开你的包的主页npmjs.com，那是一个不错的速记，npm docs。 7. 在其他脚本前后运行脚本您可能熟悉诸如pretest之类的脚本，它允许您定义在test脚本之前运行的代码。 您可能会惊讶地发现，您可以为每个脚本配置或有或后的脚本，包括您自己的自定义脚本！ 对于项目中，你使用NPM作为您的构建工具，有很多脚本，你需要自己总结使用。 8. 修改包的版本你开发一个安装包，你使用semver作为版本管理工具，修改一个新版本。 通过这种方式，你需要手动的修改package.json文件，我们不推荐这样做。 更容易的方式是运行npm version 通过 major, minor 或者 patch","tags":[{"name":"npm","slug":"npm","permalink":"http://blog.cuiyy.top/tags/npm/"}]},{"title":"pm2怎么指定master","date":"2017-08-08T06:59:46.000Z","path":"2017/08/08/7URpImMqF24g6oKs/","text":"node集群启动模式通常会这样写 123456789101112131415var cluster = require('cluster'); var http = require('http'); var os = require('os');var numCPUs = os.cpus().length;if(cluster.isMaster)&#123; for (var i = 0; i &lt; numCPUs; ++i) &#123; cluster.fork(); &#125;&#125; else &#123; http.createServer(function(req, res) &#123; res.writeHead(200); res.end(\"hello world\"); &#125;).listen(8080);&#125; 我们可以通过cluster.isMaster来执行一些任务;pm2是一个很好的nodejs 管理工具，我们可以通过配置来启动我们的nodejs服务，他的代码和我们平常写的一样。例如：123456var http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200); res.end(\"hello world\");&#125;).listen(8080); 但是我们想只在master上做一些任务，改怎么做呢？下面跟出一中方法：我们可以通过两个配置，分别指定不同的命令行参数来区别： 12345678910111213141516&#123; \"apps\" : [ &#123; \"name\": \"Master\", \"script\": \"app.js\", \"args\": [\"master\"], \"instances\": \"1\", &#125;, &#123; \"name\": \"Slave\", \"script\": \"app.js\", \"args\": [\"slave\"], \"instances\": \"-1\" &#125; ]&#125; 然后在app.js中这样写： 12345if (process.argv[2] === 'master')&#123; // ...&#125; else &#123; // ...&#125; 也可以通过其他环境变量参数来区分那个是master。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"pm2","slug":"pm2","permalink":"http://blog.cuiyy.top/tags/pm2/"}]},{"title":"搭建网盘服务器","date":"2017-07-18T02:00:11.000Z","path":"2017/07/18/YocazGnoJ07Z4rms/","text":"安装 Seafile 服务器安装依赖环境在 Debian/Ubuntu 系统下，可以使用以下命令安装 MySQL： 12sudo apt-get updatesudo apt-get install mysql-server 使用以下命令安装 Python 相关依赖： 1sudo apt-get install python2.7 python-setuptools python-imaging python-ldap python-mysqldb python-memcache python-urllib3 安装 MySQL 过程需要为 MySQL 的 root 用户设置新密码，请记住该[密码]以供后面步骤使用。 为 Seafile 创建一个用户创建 Seafile 用户，使用它运行 Seafile 服务： 1sudo useradd -m -s /bin/bash seafile 为该用户设置密码：1sudo passwd seafile 下载Seafile切换到新用户，需要输入你刚才为seafile用户设置的密码：1su - seafile 切换目录：1cd ~ 这里可以查看获取最新 Seafile 下载链接，参考以下命令进行下载。 1234wget http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.1.1_i386.tar.gz# 64位：# https://download.seadrive.org/seafile-server_6.1.1_x86-64.tar.gz 解压:12tar -xzf seafile-server_*mv seafile-server-*/ seafile-server/ 配置 Seafile运行Seafile设置脚本，并回答预设问题： 12cd seafile-server*./setup-seafile-mysql.sh 执行过程输入参数如下图：其中：[ This server’s ip or domain ] 字段输入服务器IP地址（111.111.111.111）。mysql 的 [ root password ] 字段输入数据库密码。其他字段一路回车使用默认值。 启动 Seafile12./seafile.sh start./seahub.sh start 执行过程输入参数如截图所示，其中 [ admin email ] 设置为您登录网盘的帐号，如 xxx@xxx.com[ admin password ] 和 [ admin password again ] 设置为登录网盘的密码，如 xxxxxxx 大功告成！恭喜，您的 Seafile 已经部署完成，您现在拥有专属的网盘了，登录的帐号密码为您启动 Seafile 步骤中设置的邮箱和密码。可以通过 IP 访问网盘：http://111.111.111.111:8000 注意安装过程中会出现类似错误error while loading shared libraries: libselinux.so.1: cannot open shared object file: No such file or directory 这是由于安装包与系统位不同导致的，64位系统要下载对应的64位的安装包","tags":[{"name":"网盘","slug":"网盘","permalink":"http://blog.cuiyy.top/tags/网盘/"}]},{"title":"搭建FTP服务器","date":"2017-07-17T12:10:11.000Z","path":"2017/07/17/5ykC26xyTqYUFCqG/","text":"安装并启动 FTP 服务安装 VSFTPD使用 apt-get 安装 vsftpd 1sudo apt-get install vsftpd -y 启动 VSFTPD安装完成后 VSFTPD 会自动启动，通过 netstat 命令可以看到系统已经监听了 21 端口 1sudo netstat -nltp | grep 21 如果没有启动，可以手动开启 VSFTPD 服务： 1sudo systemctl start vsftpd.service 配置用户访问目录新建用户主目录1sudo mkdir /home/uftp 执行完后，在这里 /home/uftp 就能看到新建的文件夹 uftp 了。 创建登录欢迎文件1sudo touch /home/uftp/welcome.txt ###新建用户 uftp 并设置密码创建一个用户 uftp 1sudo useradd -d /home/uftp -s /bin/bash uftp 为用户 uftp 设置密码 1sudo passwd uftp 删除掉 pam.d 中 vsftpd，因为该配置文件会导致使用用户名登录 ftp 失败： 1sudo rm /etc/pam.d/vsftpd 限制该用户仅能通过 FTP 访问限制用户 uftp 只能通过 FTP 访问服务器，而不能直接登录服务器： 1sudo usermod -s /sbin/nologin uftp 修改 vsftpd 配置 1sudo chmod a+w /etc/vsftpd.conf 修改 /etc/vsftpd.conf 文件中的配置（直接将如下配置添加到配置文件最下方）： 123456789101112131415161718# 限制用户对主目录以外目录访问chroot_local_user=YES# 指定一个 userlist 存放允许访问 ftp 的用户列表userlist_deny=NOuserlist_enable=YES# 记录允许访问 ftp 用户列表userlist_file=/etc/vsftpd.user_list# 不配置可能导致莫名的530问题seccomp_sandbox=NO# 允许文件上传write_enable=YES# 使用utf8编码utf8_filesystem=YES 新建文件 /etc/vsftpd.user_list，用于存放允许访问 ftp 的用户：12sudo touch /etc/vsftpd.user_listsudo chmod a+w /etc/vsftpd.user_list 修改 /etc/vsftpd.user_list ，加入刚刚创建的用户： 12vsftpd.user_listuftp 设置访问权限设置主目录访问权限（只读）1sudo chmod a-w /home/uftp 新建公共目录，并设置权限（读写）1sudo mkdir /home/uftp/public &amp;&amp; sudo chmod 777 -R /home/uftp/public 重启vsftpd 服务：1sudo systemctl restart vsftpd.service 访问 FTP 服务FTP 服务已安装并配置完成，下面我们来使用该 FTP 服务访问 FTP 服务根据您个人的工作环境，选择一种方式来访问已经搭建的 FTP 服务 ###通过 FTP 客户端工具访问FTP 客户端工具众多，下面推荐两个常用的：FileZilla - 跨平台的 FTP 客户端，支持 Windows 和 MacWinSCP - Windows 下的 FTP 和 SFTP 连接客户端下载和安装 FTP 客户端后，使用下面的凭据进行连接即可：主机 111.111.111.11用户：uftp 输入密码后，如果能够正常连接，那么大功告成，您可以开始使用属于您自己的 FTP 服务器了！接下来，请上传任意一张图片到您的 FTP 服务器上的 uftp 的 public 目录下，然后，就可以在 /home/uftp/public 中看到了。 ###通过 Windows 资源管理器访问Windows 用户可以复制下面的链接到资源管理器的地址栏访问： 1ftp://uftp:你的密码@111.111.111.11","tags":[{"name":"FTP","slug":"FTP","permalink":"http://blog.cuiyy.top/tags/FTP/"}]},{"title":"nodejs http.request 设置超时","date":"2017-06-23T13:19:11.000Z","path":"2017/06/23/ujZ8WMuDA7TISLvv/","text":"使用nodejs在请求第三方接口的时候，经常会用到http.request()方法；为了防止请求等待时间过长，我们可以为其设置超时时间。在请求参数中添加timeout参数例如： 1234567891011121314151617181920212223var http = require('http');var options = &#123; hostname: '127.0.0', port: 8080, path: '/x', method: 'GET', timeout: 500&#125;var req = http.request(options, function (res) &#123; res.on('data', function (chunk) &#123; console.log('BODY: ' + chunk); &#125;); res.on('end', function (error) &#123; console.log('请求完成'); &#125;); res.on('timeout', function() &#123; console.log('请求超时'); &#125;);&#125;);req.on('error', function(e) &#123; console.log('请求失败: ' + e.message); &#125;);req.end(); 请求超过500毫秒后，会终止请求，同时触发timeout事件，我们可以监听此事件，在请求超时后做一些处理。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"http","slug":"http","permalink":"http://blog.cuiyy.top/tags/http/"}]},{"title":"browsersync 省时的浏览器同步测试工具","date":"2017-06-23T01:58:32.000Z","path":"2017/06/23/Tve7kc4flBoVIhdF/","text":"Browsersync能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试。您可以想象一下：“假设您的桌子上有pc、ipad、iphone、android等设备，同时打开了您需要调试的页面，当您使用browsersync后，您的任何一次代码保存，以上的设备都会同时显示您的改动”。无论您是前端还是后端工程师，使用它将提高您30%的工作效率。 安装安装nodejs安装browsersync1npm install -g browser-sync 启动 BrowserSync静态网站如果您想要监听.css文件, 您需要使用服务器模式。 BrowserSync 将启动一个小型服务器，并提供一个URL来查看您的网站。1browser-sync start --server --files \"css/*.css\" --files 路径是相对于运行该命令的项目（目录） 如果您需要监听多个类型的文件，您只需要用逗号隔开。例如我们再加入一个.html文件 1234# --files 路径是相对于运行该命令的项目（目录） browser-sync start --server --files \"css/*.css, *.html\"# 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。 browser-sync start --server --files \"**/*.css, **/*.html\" 动态网站如果您已经有其他本地服务器环境PHP或类似的，您需要使用代理模式。 BrowserSync将通过代理URL(localhost:3000)来查看您的网站。 123# 主机名可以是ip或域名# --port 指定代理端口browser-sync start --proxy \"127.0.0.1:8080\" --port 3001 --files \"css/*.css\"","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"自动化","slug":"自动化","permalink":"http://blog.cuiyy.top/tags/自动化/"}]},{"title":"nodemon","date":"2017-06-20T08:40:13.000Z","path":"2017/06/20/Ga3g8f89sQ1zEnJ9/","text":"nodemon将监视启动nodemon的目录中的文件，如果任何文件更改，nodemon将自动重新启动node应用程序。 安装1npm install -g nodemon 用法1nodemon [your node app] 使用nodemon很简单，如果我的应用程序接受主机和端口作为参数，可以这样使用: 1nodemon ./server.js localhost 8080 nodemon还支持运行和监视coffee脚本应用程序： 1nodemon server.coffee 启用调试 1nodemon --debug ./server.js 80","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"自动化","slug":"自动化","permalink":"http://blog.cuiyy.top/tags/自动化/"}]},{"title":"yarn 快速、可靠、安全的依赖管理","date":"2017-06-20T03:35:25.000Z","path":"2017/06/20/Eyvj2n2bqaRnQFDq/","text":"yarn是类似于npm的包管理工具，相比npm,速度更快，更安全可靠。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://blog.cuiyy.top/tags/nodejs/"},{"name":"工具","slug":"工具","permalink":"http://blog.cuiyy.top/tags/工具/"}]},{"title":"Ubuntu 16 安装mongodb","date":"2017-05-02T02:58:36.000Z","path":"2017/05/02/gKAfWgqGd2uDqcHZ/","text":"通过apt-get安装软件包签名验证Ubuntu软件包管理工具（即dpkg和apt）通过要求分销商使用GPG密钥对软件包进行签名来确保软件包的一致性和真实性。1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 官方文档 为MongoDB创建一个列表文件1echo \"deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list 更新本地包数据1sudo apt-get update 安装MongoDB包1sudo apt-get install -y mongodb-org 启动|暂停|重启123sudo service mongod startsudo service mongod stopsudo service mongod restart 手动安装下载安装包1wget https://fastdl.mongodb.org/linux/mongodb-linux-arm64-ubuntu1604-3.4.4.tgz 解压1tar -xzvf mongodb-linux-arm64-ubuntu1604-3.4.4.tgz 编写Ubuntu服务文件增加/lib/systemd/system/mongod.service文件 12345678910[Unit]Description=An object/document-oriented databaseDocumentation=man:mongod(1)[Service]User=rootExecStart=/mongodb/bin/mongod --quiet --config /mongodb/mongodb.conf[Install]WantedBy=multi-user.target 重新加载service文件1systemctl daemon-reload 启动|暂停|重启123sudo service mongod startsudo service mongod stopsudo service mongod restart","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://blog.cuiyy.top/tags/mongodb/"},{"name":"Ubuntu16","slug":"Ubuntu16","permalink":"http://blog.cuiyy.top/tags/Ubuntu16/"}]}]